// Import des d√©pendances et composants n√©cessaires
import { useState, useEffect} from 'react';
import { toast } from 'react-toastify';
import { categories, equipments } from '../data/projectData';
import axios from 'axios';

// Configuration des types d'objets autoris√©s par cat√©gorie
export const categoryToTypeMap = {
  salles: ['salle', 'chauffage', 'eclairage', 'sysaudio', 'ventilation', 'store', 'projecteur'],
  ecole: ['camera', 'porte', 'eclairage', 'panneau', 'capteur', 'grille', 'alarme'],
  parking: ['camera', 'capteur', 'eclairage', 'panneau', 'borne', 'barriere']
};

export const useGestionState = () => {
    // √âtats pour la gestion des objets
    const [objects, setObjects] = useState([]); // Liste des objets filtr√©s par cat√©gorie
    const [selectedCategory, setSelectedCategory] = useState('salles'); // Cat√©gorie active
    const [showObjectModal, setShowObjectModal] = useState(false); // Visibilit√© modal d'ajout/√©dition
    const [inactiveCount, setInactiveCount] = useState(0); // Nombre d'objets inactifs
    const [objectHistories, setObjectHistories] = useState({}); // Historique des consommations
    const [allObjects, setAllObjects] = useState([]); // Liste compl√®te des objets
    const [selectedReport, setSelectedReport] = useState('total');
    const [timeFilter, setTimeFilter] = useState('day');
    const [historyTimeFilter, setHistoryTimeFilter] = useState('day');
    const [chartType, setChartType] = useState('line');
    const [initialSettings, setInitialSettings] = useState({});

    // √âtats pour les alertes et confirmations
    const [showAlert, setShowAlert] = useState(false); // Affichage des messages d'alerte
    const [alertMessage, setAlertMessage] = useState(''); // Contenu du message d'alerte
    const [showConfirmation, setShowConfirmation] = useState(false); // Dialogue de confirmation
    const [confirmationMessage, setConfirmationMessage] = useState(''); // Message de confirmation
    const [confirmationAction, setConfirmationAction] = useState(null); // Action √† ex√©cuter apr√®s confirmation

    const [selectedForChart, setSelectedForChart] = useState(null);
    const [editingObject, setEditingObject] = useState(null);

    const [objectFormData, setObjectFormData] = useState({
        name: '',
        category: selectedCategory,
        status: 'active',
        priority: 'normal',
        type: categoryToTypeMap[selectedCategory][0],
        numero: '',
        targetTemp: '',             // pour les Chauffages
        brightnessSchedule: '',     // pour √âclairage (horaire fonctionnement)
    });
    const [objectSettings, setObjectSettings] = useState({});
    const [editingSettingsFor, setEditingSettingsFor] = useState(null);

    // √âtats pour la gestion des r√©servations
    const [reservations, setReservations] = useState([]);
    const [showReservationModal, setShowReservationModal] = useState(false);
    const [reservationFormData, setReservationFormData] = useState({
        room: '',
        date: '',
        time: '',
    });

    // √âtats pour la gestion des alertes
    const [alerts, setAlerts] = useState([]);
    const [showAlertModal, setShowAlertModal] = useState(false);
    const [selectedAlert, setSelectedAlert] = useState(null);

    // √âtats pour les rapports
    const [reports, setReports] = useState({
        energyConsumption: [],
        objectUsage: [],
    });
    
    useEffect(() => {
      const fetchAll = async () => {
        try {
          const { data } = await axios.get('/api/objets');
          // renommer nom‚Üíname et etat‚Üístatus
          const mapped = data.map(o => ({
            id:     o.id,
            name:   o.nom,
            type:   o.type,
            status: o.etat,
            // Ajouter tous les autres champs potentiellement utiles
            settings: o.settings || {},
            location: o.location || '',
            description: o.description || ''
          }));
          setAllObjects(mapped);
          
          // Initialiser la liste filtr√©e pour la cat√©gorie courante
          const initial = mapped.filter(obj => 
            categoryToTypeMap[selectedCategory] && 
            categoryToTypeMap[selectedCategory].includes(obj.type.toLowerCase())
          );
          setObjects(initial);
          
          console.log("Objets r√©cup√©r√©s:", mapped);
          console.log("Objets filtr√©s pour", selectedCategory, ":", initial);
          
        } catch (err) {
          console.error('Erreur chargement objets :', err);
          toast.error("Impossible de charger les objets depuis la BDD");
        }
      };
      fetchAll();
    }, []); // une seule fois au montage
    

    useEffect(() => {
      axios.get('/api/alertes')
        .then(({ data }) => setAlerts(data))
        .catch(console.error);
    }, []);

    // Ta fonction pour cr√©er une nouvelle alerte
 // useGestionState.js

 const handleCreateAlert = async (object) => {
  try {
    const objetName = object.name;
    const message   = `Une alerte a √©t√© d√©clench√©e pour l'objet ${objetName}`;
    
    // Envoyer le message et l'ID de l'objet
    const { data: newAlert } = await axios.post('http://localhost:5001/api/alerte', { 
      message, 
      idObjet: object.id // S'assurer que l'ID de l'objet est envoy√©
    });

    // Met √† jour la liste en front
    setAlerts(prev => [newAlert, ...prev]);

    toast.success(`Alerte cr√©√©e pour ${objetName}`);
  } catch (err) {
    console.error('Erreur cr√©ation alerte :', err);
    toast.error(`√âchec de la cr√©ation de l'alerte pour ${object.name}`);
  }
};

    // G√©n√©rateur de rapports et statistiques
    const generateReports = (objectsToAnalyze) => {
        const getFilteredDates = (filter) => {
            const dates = [];
            const today = new Date();
            
            switch(filter) {
              case 'week':
                for(let i = 6; i >= 0; i--) {
                  const date = new Date();
                  date.setDate(today.getDate() - i);
                  dates.push(date.toISOString().split('T')[0]);
                }
                break;
              case 'month':
                for(let i = 29; i >= 0; i--) {
                  const date = new Date();
                  date.setDate(today.getDate() - i);
                  dates.push(date.toISOString().split('T')[0]);
                }
                break;
              default: // day
                dates.push(today.toISOString().split('T')[0]);
            }
            return dates;
        };
      
        const generateEnergyData = (objs, dates) =>
          dates.map(date => ({
            date,
            value: Math.round(objs.reduce((sum, obj) => 
              sum + (obj.status === 'active' || obj.status === 'Actif' ? 50 + Math.random() * 20 : 20)
            , 0))
          }));
      
        const dates = getFilteredDates(timeFilter);
        
        // Filtrer par type en tenant compte de la casse
        const salles = objectsToAnalyze.filter(obj => 
            categoryToTypeMap.salles.some(type => obj.type.toLowerCase() === type)
        );
        const ecole = objectsToAnalyze.filter(obj => 
            categoryToTypeMap.ecole.some(type => obj.type.toLowerCase() === type)
        );
        const parking = objectsToAnalyze.filter(obj => 
            categoryToTypeMap.parking.some(type => obj.type.toLowerCase() === type)
        );

        setReports({
          total: generateEnergyData(objectsToAnalyze, dates),
          salles: generateEnergyData(salles, dates),
          ecole: generateEnergyData(ecole, dates),
          parking: generateEnergyData(parking, dates)
        });

        // üî• Mise √† jour de l'historique des consommations par objet
        setObjectHistories(prevHistories => {
            const updatedHistories = { ...prevHistories };
            
            objectsToAnalyze.forEach(obj => {
              if (!updatedHistories[obj.id]) {
                updatedHistories[obj.id] = [];
              }
              updatedHistories[obj.id].push({
                date: new Date().toISOString().split('T')[0],
                value: obj.status === 'active' || obj.status === 'Actif' ? 50 : 20
              });
            });
          
            return updatedHistories;
        });
    };

    // Fonction d'export des rapports
    const handleExportReport = (type) => {
        // Validation des donn√©es
        const data = reports[type];
        if (!data || data.length === 0) {
            setAlertMessage("Aucune donn√©e √† exporter");
            setShowAlert(true);
            return;
        }

        // Conversion et t√©l√©chargement
        const csv = convertToCSV(data);
        downloadCSV(csv, `${type}_report.csv`);
    };

    const convertToCSV = (data) => {
        const headers = Object.keys(data[0]);
        const rows = data.map(obj => headers.map(key => obj[key]));
        return [headers.join(','), ...rows.map(r => r.join(',')).join('\n')];
    };

    const downloadCSV = (csv, filename) => {
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
    };

    const handleEditObject = (object) => {
        // Extraire le num√©ro de l'ID (qui peut √™tre un nombre ou une cha√Æne)
        let numero = '';
        if (object.id) {
            // Convertir l'ID en cha√Æne si c'est un nombre
            const idStr = String(object.id);
            // Extraire uniquement les chiffres si possible
            const match = idStr.match(/\d+/);
            numero = match ? match[0] : idStr;
        }
        
        setObjectFormData({
            name: object.name,
            description: object.description || '',
            status: object.status,
            type: object.type,
            category: selectedCategory,
            numero: numero,
            targetTemp: object.settings?.temperature || '',
            brightnessSchedule: object.settings?.startTime && object.settings?.endTime
            ? `${object.settings.startTime}-${object.settings.endTime}`
            : ''
        });
        setEditingObject(object);
        setShowObjectModal(true);
    };

    // Ajout de la fonction isNameUnique
    const isNameUnique = (name, objects, excludeId = null) => {
        return !allObjects.some(obj => 
            obj.name.toLowerCase() === name.toLowerCase() && 
            obj.id !== excludeId
        );
    };

    // Gestionnaire pour la soumission du formulaire d'objet
    const handleObjectSubmit = async (e) => {
        e.preventDefault();
        
        if (!isNameUnique(objectFormData.name, allObjects, editingObject?.id)) {
            return false; // Indique l'√©chec de la validation
        }
        
        const prefixMap = {
            salles: 'salle',
            ecole: 'ecole',
            parking: 'parking'
        };
        
        try {
            // G√©n√©rer un ID en fonction du formulaire
            let newId;
            let updatedAllObjects = [...allObjects]; // Cr√©er une copie pour travailler dessus
            
            if (editingObject) {
                // Pour la modification, conserver l'ID num√©rique existant si c'est un nombre
                newId = typeof editingObject.id === 'number' ? editingObject.id : `${prefixMap[objectFormData.category] || 'obj'}${objectFormData.numero}`;
                
                // TODO: Impl√©menter l'√©dition via l'API
                // Pour l'instant, nous utilisons la mise √† jour locale
                const newObject = {
                    id: newId,
                    name: objectFormData.name,
                    description: objectFormData.description || '',
                    type: objectFormData.type.toLowerCase(),
                    status: objectFormData.status,
                    location: objectFormData.location || '',
                    settings: {
                        temperature: objectFormData.targetTemp || null,
                        startTime: objectFormData.brightnessSchedule?.split('-')[0] || '',
                        endTime: objectFormData.brightnessSchedule?.split('-')[1] || ''
                    }
                };
                
                updatedAllObjects = allObjects.filter(obj => obj.id !== editingObject.id);
                updatedAllObjects.push(newObject);
                
            } else {
                // Pour un nouvel objet, envoyer la requ√™te √† l'API
                const { data } = await axios.post('/api/objets', {
                    type: objectFormData.type.toLowerCase(),
                    nom: objectFormData.name
                });
                
                console.log("Objet cr√©√© dans la base de donn√©es:", data);
                
                // Cr√©er un objet complet avec les donn√©es de la r√©ponse et le reste des informations du formulaire
                const newObject = {
                    id: data.id,
                    name: data.nom,
                    type: objectFormData.type.toLowerCase(),
                    status: 'Actif', // Statut par d√©faut pour un nouvel objet
                    description: objectFormData.description || '',
                    location: objectFormData.location || '',
                    settings: {
                        temperature: objectFormData.targetTemp || null,
                        startTime: objectFormData.brightnessSchedule?.split('-')[0] || '',
                        endTime: objectFormData.brightnessSchedule?.split('-')[1] || ''
                    }
                };
                
                // Ajouter le nouvel objet √† la liste des objets
                updatedAllObjects = [...allObjects, newObject];
                toast.success(`Objet ${newObject.name} cr√©√© avec succ√®s`);
            }
            
            // Mettre √† jour la liste compl√®te des objets
            setAllObjects(updatedAllObjects);
            
            // Filtrer les objets en fonction du type pour la cat√©gorie actuelle
            const filteredObjects = updatedAllObjects.filter(obj => 
                categoryToTypeMap[objectFormData.category] && 
                categoryToTypeMap[objectFormData.category].includes(obj.type.toLowerCase())
            );
            setObjects(filteredObjects);

            // Mise √† jour de la cat√©gorie active
            setSelectedCategory(objectFormData.category);

            setShowObjectModal(false);
            setEditingObject(null);
            return true; // Indique le succ√®s
        } catch (error) {
            console.error("Erreur lors de l'ajout de l'objet:", error);
            toast.error(`Erreur lors de l'ajout de l'objet: ${error.message}`);
            return false;
        }
    };
    
    // Gestionnaire pour les actions sur les alertes
    const handleCategoryChange = (categoryKey) => {
      setSelectedCategory(categoryKey);
      const types = categoryToTypeMap[categoryKey]; // ex ['salle','chauffage',‚Ä¶]
      
      if (types && allObjects.length > 0) {
        const filtered = allObjects.filter(obj => 
          types.includes(obj.type.toLowerCase())
        );
        setObjects(filtered);
        console.log(`Changement cat√©gorie vers ${categoryKey}:`, filtered);
      }
    };
      
      
      
    
    const handleAddObject = () => {
        setObjectFormData({ name: '', category: selectedCategory, status: 'active', priority: 'normal' });
        setShowObjectModal(true);
    };
    
    const handleAddReservation = () => {
        setReservationFormData({ room: '', date: '', time: '' });
        setShowReservationModal(true);
    };
    
    const handleEditReservation = (reservation) => {
        setReservationFormData({
            room: reservation.room,
            date: reservation.date,
            time: reservation.time,
        });
        setShowReservationModal(true);
    };
    
    const handleDeleteReservation = (reservationId) => {
        setConfirmationMessage('√ätes-vous s√ªr de vouloir supprimer cette r√©servation ?');
        setShowConfirmation(true);
        setConfirmationAction(() => () => {
            setReservations(reservations.filter(reservation => reservation.id !== reservationId));
            setShowConfirmation(false);
        });
    };
    
    const handleRequestDeletion = (object) => {
        // Cr√©er une alerte pour demander la suppression de l'objet
        setConfirmationMessage(`√ätes-vous s√ªr de vouloir demander la suppression de ${object.name} ?`);
        setShowConfirmation(true);
        setConfirmationAction(() => () => {
            // Ici tu peux envoyer un message ou une alerte √† l'administrateur, par exemple en ajoutant l'objet √† une liste des objets √† supprimer
            setAlertMessage(`La demande de suppression pour l'objet ${object.name} a √©t√© envoy√©e √† l'administrateur.`);
            setShowAlert(true);
            
            // Tu peux √©galement maintenir une liste d'objets √† supprimer (√† traiter c√¥t√© serveur ou administrateur)
            setAlerts(prevAlerts => [...prevAlerts, { message: `Demande de suppression pour ${object.name}`, objectId: object.id }]);
            setShowConfirmation(false);
        });
    };
    
    // // --------- Gestion des alertes ---------
    // const handleCreateAlert = (object) => {
    //     // Cr√©er une nouvelle alerte pour l'objet
    //     const newAlert = {
    //         id: Date.now(), // Un identifiant unique pour l'alerte
    //         message: `Probl√®me d√©tect√© pour ${object.name}, veuillez contacter un administrateur.`, // Message de l'alerte
    //         objectId: object.id,
    //     };
        
    //     // Ajouter l'alerte √† l'√©tat des alertes
    //     setAlerts(prevAlerts => [...prevAlerts, newAlert]);
        
    //     // Optionnel : afficher une alerte en pop-up
    //     setAlertMessage(`L'alerte pour l'objet ${object.name} a √©t√© cr√©√©e.`);
    //     setShowAlert(true);
    // };
    
    const handleAlertAction = (alert) => {
        setSelectedAlert(alert);
        setShowAlertModal(true);
    };
    
    const handleToggleStatus = (object) => {
        const nextStatus = object.status === 'active'
            ? 'inactive'
            : object.status === 'inactive'
            ? 'maintenance'
            : 'active';
        
        const updatedAll = allObjects.map(obj =>
            obj.id === object.id ? { ...obj, status: nextStatus } : obj
        );
        
        setAllObjects(updatedAll);
    };
      
    const isInefficient = (obj) => {
        // Convertir le type en minuscule pour la comparaison
        const type = obj.type.toLowerCase();
        
        if (type === 'chauffage') {
            return parseInt(obj.settings?.temperature) > 24;
        }
        if (type === 'eclairage') {
            const [start, end] = [obj.settings?.startTime, obj.settings?.endTime];
            return start === '00:00' && end === '23:59';
        }
        return false;
    };
        
    const handleOpenSettings = (object) => {
        setInitialSettings({ ...object.settings });
        setEditingSettingsFor(object);
        
        // Initialiser les param√®tres en fonction du type d'objet
        const defaultSettings = {
            // Param√®tres de base
            temperature: '',
            startTime: '',
            endTime: '',
            
            // Param√®tres par type
            mode: 'auto',
            brightness: '100',
            resolution: '1080p',
            detectionMode: 'mouvement',
            speed: '50',
        };

        // R√©cup√©rer les param√®tres existants ou utiliser les valeurs par d√©faut
        setObjectSettings({
            ...defaultSettings,
            ...object.settings
        });
    };

    const handleSaveSettings = (object) => {
            // Met √† jour la liste globale des objets
            const updatedAll = allObjects.map(obj =>
              obj.id === object.id
                ? { ...obj, settings: objectSettings }
                : obj
            );
            setAllObjects(updatedAll);
            // Met √† jour la liste filtr√©e si besoin
            setObjects(prev => prev.map(obj =>
              obj.id === object.id
                ? { ...obj, settings: objectSettings }
                : obj
            ));
          };
      
    const handleReservationSubmit = (e) => {
        e.preventDefault();
        
        if (reservationFormData.id) {
            // Modification d'une r√©servation existante
            setReservations(prev =>
            prev.map(res =>
                res.id === reservationFormData.id
                ? { ...res, ...reservationFormData }
                : res
            )
            );
        } else {
            // Nouvelle r√©servation
            const newReservation = {
            id: Date.now(),
            ...reservationFormData
            };
            setReservations(prev => [...prev, newReservation]);
        }
        
        setShowReservationModal(false);
    };

    useEffect(() => {
        const count = allObjects.filter(obj => obj.status === 'inactive').length;
        setInactiveCount(count);
      }, [allObjects]);
      
       // üëà ce useEffect ne tourne qu'une fois au montage
    
    useEffect(() => {
      // Filtrage bas√© uniquement sur les types d'objets d√©finis dans categoryToTypeMap
      // et non plus sur les items pr√©d√©finis dans les cat√©gories
      if (allObjects.length > 0) {
        const filteredObjects = allObjects.filter(object =>
          categoryToTypeMap[selectedCategory] && 
          categoryToTypeMap[selectedCategory].includes(object.type.toLowerCase())
        );
        
        console.log("Objets filtr√©s apr√®s changement de cat√©gorie:", filteredObjects);
        setObjects(filteredObjects);
      }
    }, [selectedCategory, allObjects]);
      
     // üëà nouvelle d√©pendance ici

    useEffect(() => {
        if (allObjects.length > 0) {
          generateReports(allObjects);
        }
    }, [allObjects]);
  

  return {
    initialSettings,
    handleSaveSettings,
    generateReports, handleExportReport,
    convertToCSV, downloadCSV,
    handleEditObject, handleObjectSubmit,
    handleCategoryChange, handleAddObject,
    handleAddReservation, handleEditReservation,
    handleDeleteReservation, handleRequestDeletion,
    handleCreateAlert, handleAlertAction,
    handleToggleStatus, handleOpenSettings,
    handleReservationSubmit,
    isInefficient,
    isNameUnique, // Ajout de isNameUnique dans le return
    objects, setObjects,
    selectedCategory, setSelectedCategory,
    showObjectModal, setShowObjectModal,
    inactiveCount, setInactiveCount,
    objectHistories, setObjectHistories,
    allObjects, setAllObjects,
    showAlert, setShowAlert,
    alertMessage, setAlertMessage,
    showConfirmation, setShowConfirmation,
    confirmationMessage, setConfirmationMessage,
    confirmationAction, setConfirmationAction,
    selectedForChart, setSelectedForChart,
    editingObject, setEditingObject,
    objectFormData, setObjectFormData,
    objectSettings, setObjectSettings,
    editingSettingsFor, setEditingSettingsFor,
    reservationFormData, setReservationFormData,
    showReservationModal, setShowReservationModal,
    reservations, setReservations,
    showAlertModal, setShowAlertModal,
    selectedAlert, setSelectedAlert,
    alerts, setAlerts,
    reports, setReports,
    selectedReport, setSelectedReport,
    timeFilter, setTimeFilter,
    historyTimeFilter, setHistoryTimeFilter,
    chartType, setChartType,
  };
};
